{"version":3,"file":"userIntegrations.js","sources":["../../src/userIntegrations.ts"],"sourcesContent":["import type { Integration } from '@sentry/types';\n\nexport type UserIntegrationsFunction = (integrations: Integration[]) => Integration[];\nexport type UserIntegrations = Integration[] | UserIntegrationsFunction;\nexport type IntegrationWithExclusionOption = Integration & {\n  /**\n   * Allow the user to exclude this integration by not returning it from a function provided as the `integrations` option\n   * in `Sentry.init()`. Meant to be used with default integrations, the idea being that if a user has actively filtered\n   * an integration out, we should be able to respect that choice if we wish.\n   */\n  allowExclusionByUser?: boolean;\n};\n\ntype ForcedIntegrationOptions = {\n  [keyPath: string]: unknown;\n};\n\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nexport function addOrUpdateIntegration<T extends UserIntegrations>(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: T,\n  forcedOptions: ForcedIntegrationOptions = {},\n): T {\n  return (\n    Array.isArray(userIntegrations)\n      ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n      : addOrUpdateIntegrationInFunction(\n          defaultIntegrationInstance,\n          // Somehow TS can't figure out that not being an array makes this necessarily a function\n          userIntegrations as UserIntegrationsFunction,\n          forcedOptions,\n        )\n  ) as T;\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: Integration[],\n  forcedOptions: ForcedIntegrationOptions,\n): Integration[] {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance: IntegrationWithExclusionOption,\n  userIntegrationsFunc: UserIntegrationsFunction,\n  forcedOptions: ForcedIntegrationOptions,\n): UserIntegrationsFunction {\n  const wrapper: UserIntegrationsFunction = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(\n        integration => integration.name === defaultIntegrationInstance.name,\n      );\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n\n  return wrapper;\n}\n"],"names":[],"mappings":"AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,YAAA,CAAA,GAAA,EAAA,OAAA,EAAA,KAAA,EAAA;AACA;AACA,EAAA,MAAA,KAAA,GAAA,OAAA,CAAA,KAAA,CAAA,kBAAA,CAAA,CAAA;AACA;AACA,EAAA,IAAA,KAAA,KAAA,IAAA,EAAA;AACA,IAAA,GAAA,CAAA,OAAA,CAAA,GAAA,KAAA,CAAA;AACA,GAAA,MAAA;AACA;AACA,IAAA,MAAA,QAAA,GAAA,GAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA;AACA,IAAA,YAAA,CAAA,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA,EAAA,KAAA,CAAA,CAAA;AACA,GAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,sBAAA;AACA,EAAA,0BAAA;AACA,EAAA,gBAAA;AACA,EAAA,aAAA,GAAA,EAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA,KAAA,CAAA,OAAA,CAAA,gBAAA,CAAA;AACA,QAAA,6BAAA,CAAA,0BAAA,EAAA,gBAAA,EAAA,aAAA,CAAA;AACA,QAAA,gCAAA;AACA,UAAA,0BAAA;AACA;AACA,UAAA,gBAAA;AACA,UAAA,aAAA;AACA,SAAA;AACA,KAAA;AACA,CAAA;AACA;AACA,SAAA,6BAAA;AACA,EAAA,0BAAA;AACA,EAAA,gBAAA;AACA,EAAA,aAAA;AACA,EAAA;AACA,EAAA,MAAA,YAAA,GAAA,gBAAA,CAAA,IAAA,CAAA,WAAA,IAAA,WAAA,CAAA,IAAA,KAAA,0BAAA,CAAA,IAAA,CAAA,CAAA;AACA;AACA,EAAA,IAAA,YAAA,EAAA;AACA,IAAA,KAAA,MAAA,CAAA,OAAA,EAAA,KAAA,CAAA,IAAA,MAAA,CAAA,OAAA,CAAA,aAAA,CAAA,EAAA;AACA,MAAA,YAAA,CAAA,YAAA,EAAA,OAAA,EAAA,KAAA,CAAA,CAAA;AACA,KAAA;AACA;AACA,IAAA,OAAA,gBAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,CAAA,GAAA,gBAAA,EAAA,0BAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA,SAAA,gCAAA;AACA,EAAA,0BAAA;AACA,EAAA,oBAAA;AACA,EAAA,aAAA;AACA,EAAA;AACA,EAAA,MAAA,OAAA,GAAA,mBAAA,IAAA;AACA,IAAA,MAAA,qBAAA,GAAA,oBAAA,CAAA,mBAAA,CAAA,CAAA;AACA;AACA;AACA;AACA;AACA,IAAA,IAAA,0BAAA,CAAA,oBAAA,EAAA;AACA,MAAA,MAAA,iBAAA,GAAA,qBAAA,CAAA,IAAA;AACA,QAAA,WAAA,IAAA,WAAA,CAAA,IAAA,KAAA,0BAAA,CAAA,IAAA;AACA,OAAA,CAAA;AACA,MAAA,IAAA,CAAA,iBAAA,EAAA;AACA,QAAA,OAAA,qBAAA,CAAA;AACA,OAAA;AACA,KAAA;AACA;AACA,IAAA,OAAA,6BAAA,CAAA,0BAAA,EAAA,qBAAA,EAAA,aAAA,CAAA,CAAA;AACA,GAAA,CAAA;AACA;AACA,EAAA,OAAA,OAAA,CAAA;AACA;;;;"}